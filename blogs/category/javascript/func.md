---
title: 深入理解函数
date: 2021-12-20
tags:
- 深入理解函数
categories:
-  javascript
---

### 函数的声明方式

```
1.函数的声明语句
```

<img src="../images/image-20211111192917525.png" alt="image-20211111192917525"  />

```
2.函数的表达式:将一个匿名函数赋值给一个新的变量
```

![image-20211111193156863](../images/image-20211111193156863.png)

![image-20211111193226618](../images/image-20211111193226618.png)

```
3.Function 构造函数
```

![image-20211111193313242](../images/image-20211111193313242.png)

### 函数返回值

```
如果没有返回值，调用表达式的结果是undefined
```

![image-20211111193516093](../images/image-20211111193516093.png)

```
并不是所有的函数中的return之后的代码都不执行
```

![image-20211111193629902](../images/image-20211111193629902.png)

```
一个函数可以有多个return语句
```

![image-20211111193657165](../images/image-20211111193657165.png)

```
如果函数调用时在前面加上new前缀,且返回值不是一个对象,则返回该对象 (this)
```

![image-20211111194422139](../images/image-20211111194422139.png)

![image-20211111194455723](../images/image-20211111194455723.png)

```
如果返回值是一个对象,则返回该对象
```

![image-20211111194123880](../images/image-20211111194123880.png)

![image-20211111194146695](../images/image-20211111194146695.png)

### 函数调用

```
函数调用4种方式: 函数调用模式,方法调用模式,构造调用模式,间接调用模式
```

#### 函数调用模式

![image-20211111194642633](../images/image-20211111194642633.png)

~~~
重写
~~~

![image-20211111195209894](../images/image-20211111195209894.png)

![image-20211111195612113](../images/image-20211111195612113.png)

上图结果会发现控制台的所有window对象的a都是5

![image-20211111195416162](../images/image-20211111195416162.png)

![image-20211111195509433](../images/image-20211111195509433.png)

#### 构造函数调用模式

```
this指向问题: 当做普通函数调用,this指向了window,
当做构造函数调用,this指向当前的函数,
当做对象的方法,这个this一般情况指向了当前的对象
```

```
 function fn(x,y){
   this.a = x + y;
}
```

```
var a = new fn;//等价于var a = new fn();
```

#### 间接调用模式

![image-20211111200901324](../images/image-20211111200901324.png)

![image-20211111200911908](../images/image-20211111200911908.png)

![image-20211111200930573](../images/image-20211111200930573.png)

![image-20211111201025317](../images/image-20211111201025317.png)

### 函数参数

```
arguments
函数不介意传递进来多少个参数,也不在乎传进来的参数是什么数据类型,甚至可以不传参数
```

![image-20211111201245106](../images/image-20211111201245106.png)

![image-20211111201259600](../images/image-20211111201259600.png)

```
同名形参报错
```

![image-20211111201428598](../images/image-20211111201428598.png)

```
实参比形参个数少,剩下的形参都将设置为undefined
```

```
实参比形参个数多,考虑arguments
arguments它不是真正的数组,它是类数组,它能通过[]来访问它的每一个元素
```

![image-20211111201816293](../images/image-20211111201816293.png)

```
形参的个数 方法名.length 
```

### 函数重载

```
重载 :定义相同的函数名,传入的不同参数,实现不同的功能
```

```
在js中函数不存在重载现象
```

![image-20211111202209206](../images/image-20211111202209206.png)

### 参数传递

```
1.基本数据类型
在向参数传递基本数据类型的值时,被传递的值会被复制到一个局部变量
```

```
2.引用数据类型
在向参数传递引用数据类型的值时，会把这个值在内存中的地址复制给局部变量
```

![image-20211111203239078](../images/image-20211111203239078.png)

### 函数属性

```
arguments对象中的length属性表示实参,而函数参数length属性表示的是形参的个数
```

```
name指的是当前函数的名字
```

```
prototype 属性
每一个函数都有一个prototype属性
关于原型对象 后面面向对象的课程中会详细讲
```

### 函数的方法

```
每个函数都包含两个非继承而来的方法
apply() call()
```

```
在非严格模式下,如果我们使用call()或者是apply()方法,传入一个null或者undefined会被转换成一个全局window对象
```

```
在严格模式下,函数的指向始终是指定的值
```

### call和apply的应用

```
1.找出数组的最大元素 Math.max().apply(null,arr)
```

```
2.将类数组转换成真正的数组
Array.prototype.slice.apply(arguments)
```

```
3.数组追加
Array.prototype.push.apply(arr,[1,2,3,4]);
```

```
4.利用call和apply做继承
```

![image-20211111205238805](../images/image-20211111205238805.png)

```
5.使用log代理console.log()
```

![image-20211111205508403](../images/image-20211111205508403.png)

### bind方法的用法

```
bind es5新增的方法,主要作用:将函数绑定到某个对象中,并且有返回值(一个函数)
```

```
常见的函数式编程技术- 函数柯里化
```

![image-20211111210232930](../images/image-20211111210232930.png)

